import { Component } from '@angular/core';

@Component({
  standalone: false,
  template: `
    <app-page-layout
      pageTitle="Brak prze≈Çadowa≈Ñ"
      fileEntry="./app/with-java-compare/differences/no-overload-page.component.ts"
    >
      <section class="container content">
        <app-remark [markdown]="introduction" />

        <app-remark [markdown]="methodOverloading" />

        <div class="columns my-3">
          <div class="column">
            <div class="box has-background-info-invert">
              <h4 class="title is-5">‚òï Java - Prze≈Çadowanie metod</h4>
              <app-remark [markdown]="javaMethodExample" />
            </div>
          </div>
          <div class="column">
            <div class="box has-background-warning-invert">
              <h4 class="title is-5">üü® JavaScript - Brak prze≈Çadowa≈Ñ</h4>
              <app-remark [markdown]="jsMethodExample" />
            </div>
          </div>
        </div>

        <app-remark [markdown]="constructorOverloading" />

        <div class="columns my-3">
          <div class="column">
            <div class="box has-background-info-invert">
              <h4 class="title is-5">‚òï Java - Prze≈Çadowanie konstruktor√≥w</h4>
              <app-remark [markdown]="javaConstructorExample" />
            </div>
          </div>
          <div class="column">
            <div class="box has-background-warning-invert">
              <h4 class="title is-5">üü® JavaScript - Jeden konstruktor</h4>
              <app-remark [markdown]="jsConstructorExample" />
            </div>
          </div>
        </div>

        <app-remark [markdown]="tsWorkaround" />

        <div class="box has-background-warning-invert my-3">
          <h4 class="title is-5">üî∑ TypeScript - Function Overload Signatures</h4>
          <app-remark [markdown]="tsOverloadExample" />
        </div>

        <app-remark [markdown]="conclusion" />
      </section>
    </app-page-layout>
  `,
  styles: ``,
})
export class NoOverloadPageComponent {

  introduction = `
# Brak prze≈Çadowa≈Ñ w JavaScript

**Kluczowa r√≥≈ºnica:** Java wspiera **prze≈Çadowanie metod i konstruktor√≥w** (method/constructor overloading) - mo≈ºesz mieƒá wiele metod o tej samej nazwie z r√≥≈ºnymi sygnaturami. JavaScript **nie wspiera prze≈Çadowa≈Ñ** - mo≈ºe istnieƒá tylko jedna funkcja o danej nazwie.

## üîë Co to jest prze≈Çadowanie (overloading)?

Prze≈Çadowanie pozwala na zdefiniowanie wielu wersji tej samej metody/konstruktora z **r√≥≈ºnymi parametrami**:
- ‚úÖ **Java**: Kompilator wybiera odpowiedniƒÖ wersjƒô na podstawie liczby i typ√≥w argument√≥w
- ‚ùå **JavaScript**: P√≥≈∫niejsza definicja nadpisuje wcze≈õniejszƒÖ
- ‚ö†Ô∏è **TypeScript**: Ma sk≈Çadniƒô prze≈Çadowa≈Ñ, ale to tylko type checking - w runtime dzia≈Ça jak JS
  `;

  methodOverloading = `
## üîß Prze≈Çadowanie metod
  `;

  javaMethodExample = `
\`\`\`java
public class Calculator {
    // ‚úÖ Trzy r√≥≈ºne metody o tej samej nazwie!

    // 1. Dodawanie dw√≥ch liczb int
    public int add(int a, int b) {
        System.out.println("add(int, int)");
        return a + b;
    }

    // 2. Dodawanie trzech liczb int
    public int add(int a, int b, int c) {
        System.out.println("add(int, int, int)");
        return a + b + c;
    }

    // 3. Dodawanie dw√≥ch liczb double
    public double add(double a, double b) {
        System.out.println("add(double, double)");
        return a + b;
    }

    public static void main(String[] args) {
        Calculator calc = new Calculator();

        calc.add(5, 3);           // Wywo≈Çuje add(int, int)
        calc.add(5, 3, 2);        // Wywo≈Çuje add(int, int, int)
        calc.add(5.5, 3.2);       // Wywo≈Çuje add(double, double)
    }
}
\`\`\`

**Kompilator wybiera odpowiedniƒÖ wersjƒô na podstawie argument√≥w!**
  `;

  jsMethodExample = `
\`\`\`javascript
class Calculator {
  // ‚ùå Tylko jedna metoda mo≈ºe istnieƒá o danej nazwie!

  add(a, b) {
    console.log("add(a, b)");
    return a + b;
  }

  // To NADPISUJE poprzedniƒÖ metodƒô add!
  add(a, b, c) {
    console.log("add(a, b, c)");
    return a + b + c;
  }
}

const calc = new Calculator();

// Istnieje tylko ostatnia definicja!
calc.add(5, 3);        // add(a, b, c) -> wynik: NaN (c jest undefined)
calc.add(5, 3, 2);     // add(a, b, c) -> wynik: 10

// ‚úÖ ROZWIƒÑZANIE: Parametry opcjonalne i sprawdzanie
class CalculatorFixed {
  add(a, b, c) {
    if (c !== undefined) {
      console.log("Three numbers");
      return a + b + c;
    }
    console.log("Two numbers");
    return a + b;
  }
}

const calc2 = new CalculatorFixed();
calc2.add(5, 3);       // Two numbers -> 8
calc2.add(5, 3, 2);    // Three numbers -> 10
\`\`\`

**P√≥≈∫niejsza definicja nadpisuje wcze≈õniejszƒÖ!**
  `;

  constructorOverloading = `
## üèóÔ∏è Prze≈Çadowanie konstruktor√≥w
  `;

  javaConstructorExample = `
\`\`\`java
public class Person {
    private String name;
    private int age;
    private String city;

    // ‚úÖ Konstruktor 1 - tylko imiƒô
    public Person(String name) {
        this.name = name;
        this.age = 0;
        this.city = "Unknown";
        System.out.println("Constructor(String)");
    }

    // ‚úÖ Konstruktor 2 - imiƒô i wiek
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
        this.city = "Unknown";
        System.out.println("Constructor(String, int)");
    }

    // ‚úÖ Konstruktor 3 - wszystkie pola
    public Person(String name, int age, String city) {
        this.name = name;
        this.age = age;
        this.city = city;
        System.out.println("Constructor(String, int, String)");
    }

    public static void main(String[] args) {
        Person p1 = new Person("Jan");              // Konstruktor 1
        Person p2 = new Person("Anna", 25);         // Konstruktor 2
        Person p3 = new Person("Piotr", 30, "Warsaw"); // Konstruktor 3
    }
}
\`\`\`

**Kompilator wybiera odpowiedni konstruktor!**
  `;

  jsConstructorExample = `
\`\`\`javascript
class Person {
  // ‚ùå Tylko JEDEN konstruktor mo≈ºe istnieƒá!

  constructor(name) {
    this.name = name;
    this.age = 0;
    this.city = "Unknown";
    console.log("Constructor(name)");
  }

  // To NADPISUJE poprzedni konstruktor!
  constructor(name, age, city) {
    this.name = name;
    this.age = age;
    this.city = city;
    console.log("Constructor(name, age, city)");
  }
}

// Istnieje tylko ostatnia definicja konstruktora!
const p1 = new Person("Jan");              // age=undefined, city=undefined
const p2 = new Person("Anna", 25);         // city=undefined
const p3 = new Person("Piotr", 30, "Warsaw"); // Dzia≈Ça poprawnie

// ‚úÖ ROZWIƒÑZANIE: Parametry opcjonalne z warto≈õciami domy≈õlnymi
class PersonFixed {
  constructor(name, age = 0, city = "Unknown") {
    this.name = name;
    this.age = age;
    this.city = city;
    console.log(\`Created: \${name}, \${age}, \${city}\`);
  }
}

const p4 = new PersonFixed("Jan");              // Jan, 0, Unknown
const p5 = new PersonFixed("Anna", 25);         // Anna, 25, Unknown
const p6 = new PersonFixed("Piotr", 30, "Warsaw"); // Piotr, 30, Warsaw

// ‚úÖ ALTERNATYWA: Obiekt konfiguracyjny
class PersonConfig {
  constructor({ name, age = 0, city = "Unknown" }) {
    this.name = name;
    this.age = age;
    this.city = city;
  }
}

const p7 = new PersonConfig({ name: "Jan" });
const p8 = new PersonConfig({ name: "Anna", age: 25 });
const p9 = new PersonConfig({ name: "Piotr", age: 30, city: "Warsaw" });
\`\`\`

**JavaScript ma tylko jeden konstruktor - u≈ºywamy parametr√≥w opcjonalnych!**
  `;

  tsWorkaround = `
## üî∑ TypeScript - Function Overload Signatures

TypeScript ma sk≈Çadniƒô prze≈Çadowa≈Ñ, ale to **tylko type checking** - w runtime dzia≈Ça jak JavaScript!
  `;

  tsOverloadExample = `
\`\`\`typescript
class Calculator {
  // Overload signatures (tylko typy!)
  add(a: number, b: number): number;
  add(a: number, b: number, c: number): number;
  add(a: string, b: string): string;

  // Implementation signature (jedyna rzeczywista implementacja!)
  add(a: number | string, b: number | string, c?: number): number {
    if (typeof a === "string" && typeof b === "string") {
      return Number(a) + Number(b);  // Rzutowanie i dodanie do siebie liczb
    }

    if (typeof a === "number" && typeof b === "number") {
      if (c !== undefined) {
        return a + b + c;  // dodanie trzech liczb
      }
      return a + b;  // dodanie dw√≥ch liczby
    }

    throw new Error("Invalid arguments");
  }
}

const calc = new Calculator();

// TypeScript sprawdza typy w czasie kompilacji
calc.add(5, 3);           // ‚úÖ number
calc.add(5, 3, 2);        // ‚úÖ number
calc.add("Hello", "World"); // ‚úÖ string

// calc.add(5, "test");   // ‚ùå Error: No overload matches

// Ale w skompilowanym JS jest tylko JEDNA metoda add!
\`\`\`

**Uwaga:** Overload signatures w TypeScript to tylko adnotacje typ√≥w. W JavaScript jest tylko jedna implementacja metody, kt√≥ra musi obs≈Çu≈ºyƒá wszystkie przypadki!
  `;

  conclusion = `
## üéØ Podsumowanie

| Aspekt | Java | JavaScript | TypeScript |
|--------|------|------------|------------|
| **Prze≈Çadowanie metod** | ‚úÖ TAK - wiele metod o tej samej nazwie | ‚ùå NIE - tylko jedna definicja | ‚ö†Ô∏è Tylko type checking |
| **Prze≈Çadowanie konstruktor√≥w** | ‚úÖ TAK - wiele konstruktor√≥w | ‚ùå NIE - tylko jeden konstruktor | ‚ö†Ô∏è Tylko type checking |
| **Wyb√≥r wersji** | Kompilator wybiera na podstawie argument√≥w | N/A | TypeScript sprawdza typy |
| **Runtime** | R√≥≈ºne metody w bytecode | Tylko jedna funkcja | Tylko jedna funkcja (jak JS) |
| **Alternatywy** | - | Parametry opcjonalne, rest parameters, sprawdzanie typ√≥w | Overload signatures + implementacja, union types |

### üí° Kluczowe r√≥≈ºnice:

**Java:**
- **Prawdziwe prze≈Çadowanie** - kompilator tworzy osobne metody
- Wyb√≥r metody w czasie kompilacji na podstawie typ√≥w i liczby argument√≥w
- Bardzo wygodne dla tworzenia czytelnego API

**JavaScript:**
- **Brak prze≈Çadowa≈Ñ** - p√≥≈∫niejsza definicja nadpisuje wcze≈õniejszƒÖ
- U≈ºywamy **parametr√≥w opcjonalnych** z warto≈õciami domy≈õlnymi
- U≈ºywamy **rest parameters** (\`...args\`) dla zmiennej liczby argument√≥w
- Mo≈ºemy sprawdzaƒá typy i liczbƒô argument√≥w wewnƒÖtrz funkcji

**TypeScript:**
- **Overload signatures** zapewniajƒÖ type safety w czasie kompilacji
- W runtime kompiluje siƒô do **jednej funkcji** JavaScript
- Implementacja musi obs≈Çu≈ºyƒá wszystkie przypadki z signatures
- To tylko "≈Çadna fasada" dla type checkera

### üìö Praktyczne wzorce w JavaScript/TypeScript:

\`\`\`typescript
// 1. Parametry z warto≈õciami domy≈õlnymi
function greet(name: string, greeting = "Hello") {
  return \`\${greeting}, \${name}!\`;
}

// 2. Rest parameters
function sum(...numbers: number[]): number {
  return numbers.reduce((a, b) => a + b, 0);
}

// 3. Obiekt konfiguracyjny
function createUser({ name, age = 18, role = "user" }: { name: string; age?: number; role?: 'user' | 'admin' }) {
  return { name, age, role };
}

// 4. Sprawdzanie typu/liczby argument√≥w
function process(data: string | string[] | null) {
  if (typeof data === "string") {
    return data.toUpperCase();
  }
  if (Array.isArray(data)) {
    return data.length;
  }
  return null;
}
\`\`\`

> **Wniosek:** Brak prze≈Çadowa≈Ñ w JavaScript to nie problem - idiomatyczne wzorce (opcjonalne parametry, rest parameters, destructuring) sƒÖ czƒôsto bardziej elastyczne ni≈º Java overloading!
  `;
}
